- [ 注册、登录模块](#head1)
	- [ 注册](#head2)
	- [ 登录](#head3)
- [ 个性化推荐模块](#head4)
- [ 主页热门标签显示模块](#head5)
- [_HostHolder和TagCache的设计解决并发问题](#head6)



## <span id="head1"> 注册、登录模块</span>
### <span id="head2"> 注册</span>
1. 检查是否允许注册。当用户点击页面顶部“登录”按钮，打开注册页面，允许注册时，输入账户、密码和邮箱，通过表单提交注册数据。
2. 服务端对用户输入的信息进行检测。填入的信息不能为空，验证输入的账户是否已经存在，填写的邮箱是否已经注册过。
3. 注册用户。用户传入的密码通过 MD5+salt 的方式加密，设置用户的类型为普通用户，用户的状态为未激活状态，设置用户的激活码，给用户随机分配系统自带的头像，
生成用户注册的时间。
4. 激活注册账号。服务端利用模板引擎发送激活邮件至用户注册时填写的邮箱中。
用户点击邮件中的激活码，访问服务端的激活服务。通过验证激活码来验证激活是否成功。
5. 利用kaptcha生成验证码，将验证码放入cookie中，并存到Redis里。

### <span id="head3"> 登录</span>
1. 登录方式分为论坛注册账户登录和第三方账号登录（github和qq）。
2. 论坛内注册的账户登录：提交账户信息后，服务端会先验证用户填入的信息，其中验证码在表现层就要判断，验证码不对密码和账号就不要判断了；
登录信息无误后，生成登录凭证（loginTicket），将登录凭证放入cookie中，并存到Redis里。浏览器每次访问时从Redis中取出cookie，并判断登录状态。此处Redis
存储cookie实现了分布式的部署。
3. 第三方登录：选择第三方登录后，会去相应的第三方服务器中获取用户信息并返回给服务端。服务端会通过返回的用户信息中的openId来判断该用户是否已经注册。
若注册过即取出并登录，否则注册并登录。同时生成登录凭证，放入cookie里，存到Redis中，用户下次访问时判断是否登录。

## <span id="head4"> 个性化推荐模块</span>
1. 整体上本模块采用"推"和"拉"的方式并存。
2. 当用户点赞，评论，发布博客时，会将这些"动态"封装成feed对象存入数据库，同时将这个动态发给所有的粉丝（从数据库中找到所有的粉丝，筛选最近n天登陆过的人，然后将此feed存入他们对应的redis的timelineKey中，即
每个用户的redis的timelineKey中存放着自己关注的对象的动态）
3. 当用户登录后，redis中有值则从redis中对应的key中取，否则先从redis中获取所有的关注的人，然后从数据库中遍历搜索。 至此，获得了用户关注的人的最近动态
4. 当用户每查看一个帖子时，就会将这个帖子的标签存到redis对应的tagKey中。
5. 最终，用户的个性化页面展示顺序即为：
    1. 用户关注的人发送的帖子
    2. 用户关注的人点赞的帖子
    3. 用户关注的人评论的帖子
    4. 用户最近查看的标签对应的帖子且发布时间是近期(否则用户看了两个"多线程"的帖子，然后向此用户推荐了网站所有的多线程，显然不合适，所以只推荐最近发布的"多线程"的帖子)
    5. 再按照分数递减的顺序
    

**注意点**

1. 我们为timelineKey设置了生存时间，如小葛关注了小芳，需要判断小葛N天内是否登录，
    - 步骤
        - 如果登录则小芳发布的帖子，进入了小葛的timelineKey，
        - 如果小葛5天没登录了，此时小葛的timelineKey将被自动删除，则从此小芳的点赞评论都不需要告诉小葛（占redis内存），
        - 只有当小葛再次登录时，则小芳发布的帖子，评论点赞才会进入小葛的timelineKey，以此解决redis内存。
    - 那么我们如何判断小葛N天内登录过呢？
        - redis里有个session登录凭证，但这个时间记住密码是30天，不记住密码则是7天，显然不合适，所以我们为redis中增加一个字段
        - 每次小葛登录，在redis中为user:login_5:{userId}随意设置一个值，过期时间为5天
        - 当小葛再次登录时， 再次设置，此时相当于过期时间刷新
        - 当小芳登录时，判断 user:login_5:{userId} 是否存在，存在则向timelineKey中push（并写数据库），否则就只写数据库
            - 此时写数据库是异步的，所以不会影响正常逻辑，且当小葛5天内登陆过，则5天内再次登录可能性很大，当他再次登录，直接从redis中取，速度很快，且对mysql压力小
2. 如果我们最近查看了"多线程"，那么分页查询第一页一定是0-10，这时候我们看的帖子的标签就会被redis记录，此时如果我们点击第二页，则从redis中的tagKey取值时，第二页的查询条件就会改变，
这时候可能第一页查看过的数据，第二页又会出现，或者是有些数据，永远看不到，即我们需要保证分页查询时，每次查询条件不变，所以我们设置了两个key,持久化key（persistence）和最近的key(latest),
这时候我们每次查询都从持久化key中取，而每次查询**第一页**时，将持久化key置换为最新的key，这样即可以保证每次查询条件相同，且是伪最新的标签。

## <span id="head5"> 主页热门标签显示模块</span>
1. 用户发布帖子时，都会附带一个tag标签
2. 使用quartz，每隔3个小时统计一次。遍历所有帖子，统计所有出现的标签。
3. 根据每个标签匹配所有帖子，统计含有此标签的帖子的总数，计算帖子总分，组成一个tag。这里需要注意，我们在查询某标签（如算法）对应的帖子时，
查询数据库的算法使用了“%XX%”（如%算法%）的匹配条件，这会得到其他相关联的标签（如“算法总结”等）。
4. 使用treeSet对这些标签按照总分排序，然后选出N个帖子存储在tagCache中，每当用户访问主页面时，就从TagCache中去取
5. 当帖子数量增多时，统计时间也可以设置为每天晚上3点，夜深人静偷偷统计。（统计帖子的个数，有点误差可以接受，所以一天统计一次似乎也可行）


## <span id="head6"> HostHolder和TagCache的设计解决并发问题</span>
1. HostHolder和TagCache两个类都分别有一个成员变量User类型的users和List类型showTags，在高并发环境下会存在并发问题。
2. 对于HostHolder的设计，我们使用了ThreadLocal解决了并发问题；
3. 对于TagCache的设计，由于ArrayList是线程不安全的，首先舍弃；其次考虑了线程安全的Vector，但是Vector底层是在读写上加Synchronized，
   对于多读少写的环境而言效率很低；再其次考虑了Collections.SynchronizedList()，其底层也是给set和get加Synchronized，同样效率低；最后用CopyOnWriteList来实现的，其读写分离的思想十分适合
   多读少写的环境，巧妙的解决了并发问题，且效率高。